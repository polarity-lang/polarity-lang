data Nat {
    Z,
    S(n: Nat)
}

impl Nat {
    def Nat.add(y: Nat) : Nat {
        Z => y,
        S(x') => S(x'.add(y))
    }
}

data Bool {
    True,
    False
}

impl Bool {
    def Bool.and(y: Bool) : Bool {
        True => y,
        False => False
    }
}

data Top {
    Unit
}

impl Top {
    -- FIXME: Implement typed holes
    def Top.unimplemented(a: Type) : a {
        Unit => Unit.unimplemented(a)
    }

    def Top.example(): Exp {
        Unit => And(IsZero(Add(Num(Z), Num(Z))), Boo(True))
    }

    def Top.example_has_type(): HasType(And(IsZero(Add(Num(Z()), Num(Z()))), Boo(True())), BooT) {
        Unit => TAnd(IsZero(Add(Num(Z), Num(Z))), Boo(True),
            TIsZero(Add(Num(Z), Num(Z)), TAdd(Num(Z), Num(Z), TNum(Z), TNum(Z))),
            TBoo(True)
        )
    }
}

data Exp {
    Num(n: Nat),
    Boo(b: Bool),
    Add(lhs: Exp, rhs: Exp),
    IsZero(e: Exp),
    And(lhs: Exp, rhs: Exp),
}

data Typ {
    NumT,
    BooT,
}

data HasType(e: Exp, t: Typ) {
    TNum(n: Nat) : HasType(Num(n), NumT),
    TBoo(b: Bool) : HasType(Boo(b), BooT),
    TAdd(lhs: Exp, rhs: Exp, h_lhs: HasType(lhs, NumT), h_rhs: HasType(rhs, NumT)) : HasType(Add(lhs, rhs), NumT),
    TIsZero(e: Exp, h: HasType(e, NumT)) : HasType(IsZero(e), BooT),
    TAnd(lhs: Exp, rhs: Exp, h_lhs: HasType(lhs, BooT), h_rhs: HasType(rhs, BooT)) : HasType(And(lhs, rhs), BooT),
}

data IsVal(e: Exp) {
    VNum(n: Nat) : IsVal(Num(n)),
    VBoo(b: Bool) : IsVal(Boo(b)),
}

data Eval(e1: Exp, e2: Exp) {
    EAddCongL(lhs: Exp, lhs': Exp, rhs: Exp, h_lhs: Eval(lhs, lhs')): Eval(Add(lhs, rhs), Add(lhs', rhs)),
    EAddCongR(lhs: Exp, rhs: Exp, rhs': Exp, h_rhs: Eval(rhs, rhs')): Eval(Add(lhs, rhs), Add(lhs, rhs')),
    EAddRed(n1: Nat, n2: Nat): Eval(Add(Num(n1), Num(n2)), Num(n1.add(n2))),
    EIsZeroCong(e: Exp, e': Exp, h_e: Eval(e, e')) : Eval(IsZero(e), IsZero(e')),
    EAndCongL(lhs: Exp, lhs': Exp, rhs: Exp, h_lhs: Eval(lhs, lhs')): Eval(And(lhs, rhs), And(lhs', rhs)),
    EAndCongR(lhs: Exp, rhs: Exp, rhs': Exp, h_rhs: Eval(rhs, rhs')): Eval(And(lhs, rhs), And(lhs, rhs')),
    EAndRed(b1: Bool, b2: Bool): Eval(And(Boo(b1), Boo(b2)), Boo(b1.and(b2))),
}

impl Eval {
    def Eval(e1, e2).preserves(e1: Exp, e2: Exp, t: Typ, h1: HasType(e1, t)) : HasType(e2, t) {
        EAddCongL(lhs, lhs', rhs, h_lhs)
            => Unit.unimplemented(HasType(e2, t)),
        EAddCongR(lhs, rhs, rhs', h_rhs)
            => Unit.unimplemented(HasType(e2, t)),
        EAddRed(n1, n2)
            => Unit.unimplemented(HasType(e2, t)),
        EIsZeroCong(e, e', h_e)
            => Unit.unimplemented(HasType(e2, t)),
        EAndCongL(lhs, lhs', rhs, h_lhs)
            => Unit.unimplemented(HasType(e2, t)),
        EAndCongR(lhs, rhs, rhs', h_rhs)
            => Unit.unimplemented(HasType(e2, t)),
        EAndRed(b1, b2)
            => Unit.unimplemented(HasType(e2, t))
    }
}
