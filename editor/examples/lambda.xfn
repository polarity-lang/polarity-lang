data Bot {}

def Bot.elim_bot(a: Type): a {}

data Eq (a: Type, x y: a) {
    Refl(a: Type, x: a) : Eq(a, x, x)
}

codata Fun(a b: Type) {
    Fun(a, b).apply(a: Type, b: Type, x: a) : b
}

def Eq(a, x, y).sym(a: Type, x: a, y: a) : Eq(a, y, x) {
    Refl(a, x) => Refl(a, x)
}

def Eq(a, x, y).transport(a: Type, x: a, y: a, p: Fun(a, Type), prf: p.apply(a, Type, x)) : p.apply(a, Type, y) {
    Refl(a, x) => prf
}

data Exists(a: Type, p: Fun(a, Type)) {
    MkExists(a: Type, p: Fun(a, Type), x: a, prf: p.apply(a, Type, x)): Exists(a, p)
}

data Or(a: Type, b: Type) {
    Inl(a: Type, b: Type, x: a) : Or(a, b),
    Inr(a: Type, b: Type, x: b) : Or(a, b),
}

data Bool { True, False }

def Bool.then_else(a: Type, then else: a): a {
    True => then,
    False => else,
}

data Nat {
    Z,
    S(n: Nat)
}

def Nat.add(y: Nat) : Nat {
    Z => y,
    S(x) => S(x.add(y)),
}

def Nat.pred : Nat {
    Z => Z,
    S(x) => x,
}

def Nat.eq(y: Nat): Bool {
    Z => y.match _ {
        Z => True,
        S(_) => False,
    },
    S(x) => y.match _ {
        Z => False,
        S(y') => x.eq(y')
    }
}

def Nat.geq(y: Nat): Bool {
    Z => y.match _ {
        Z => True,
        S(_) => False,
    },
    S(x) => y.match _ {
        Z => True,
        S(y') => x.geq(y')
    }
}

data Typ {
    FunT(t1 t2: Typ),
    VarT(x: Nat),
}

data Ctx {
    Nil,
    Cons(t: Typ, ts: Ctx),
}

def (self: Ctx).inversion: Or(Eq(Ctx, self, Nil), Exists(Typ, comatch _ { apply(_, _, t) => Exists(Ctx, comatch _ { apply(_, _, ts) => Eq(Ctx, self, Cons(t, ts))}) })) {
    Nil => Inl(Eq(Ctx, Nil, Nil), Exists(Typ, comatch _ { apply(_, _, t) => Exists(Ctx, comatch _ { apply(_, _, ts) => Eq(Ctx, Nil, Cons(t, ts))}) }), Refl(Ctx, Nil)),
    Cons(x, xs) => Inr(Eq(Ctx, Cons(x, xs), Nil), Exists(Typ, comatch _ { apply(_, _, t) => Exists(Ctx, comatch _ { apply(_, _, ts) => Eq(Ctx, Cons(x, xs), Cons(t, ts))}) }),
        MkExists(Typ, comatch _ { apply(_, _, t) => Exists(Ctx, comatch _ { apply(_, _, ts) => Eq(Ctx, Cons(x, xs), Cons(t, ts))}) },
            x, MkExists(Ctx, comatch _ { apply(_, _, ts) => Eq(Ctx, Cons(x, xs), Cons(x, ts) )}, xs, Refl(Ctx, Cons(x, xs)))
        )
    ),
}

data Elem(x: Nat, t: Typ, ctx: Ctx) {
    Here(t: Typ, ts: Ctx): Elem(Z, t, Cons(t, ts)),
    There(x: Nat, t: Typ, t2: Typ, ts: Ctx, prf: Elem(x, t, ts)): Elem(S(x), t, Cons(t2, ts)),
}

def Elem(x, t, Nil).empty_absurd(x: Nat, t: Typ) : Bot {
    Here(_, _) absurd,
    There(_, _, _, _, _) absurd,
}

def Elem(x, t, ctx).unique(ctx: Ctx, x: Nat, s t: Typ, h: Elem(x, s, ctx)): Eq(Typ, s, t) {
    Here(t, ts) => h.match _ {
        Here(s, ss) => ?,
        -- Elem(Z, @1.2, Cons(@0.1, @0.0))
        -- h: Elem(x, s, ctx)
        There(_, _, _, _, _) absurd,
    },
    There(_, _, _, _, _) => ?,
}

data Top { Unit }

def Top.hole(a: Type, x: a, b: Type) : b {
    Unit => Unit.hole(a, x, b)
}

def Top.lemma3(rs: Ctx, r s: Typ, h1: Elem(Z, s, Cons(r, rs))) : Eq(Typ, r, s) {
    Unit => h1.match _ {
        Here(_, _) => Refl(Typ, s),
        There(_, _, _, _, _) absurd,
    }
}

def Top.lemma2(ctx ctx': Ctx, s t: Typ, h1: Elem(Z, s, ctx), h2: Elem(Z, t, ctx)) : Eq(Typ, s, t) {
    Unit => ctx.match _ {
        Cons(r, rs) => ?,
        Nil => ?,
    }
}

def Top.lemma1(ctx: Ctx, x: Nat, s t: Typ, h1: Elem(x, s, ctx), h2: Elem(x, t, ctx)) : Eq(Typ, s, t) {
    Unit => ctx.match _ {
        Nil => h1.match _ {
            Here(_, _) => ?,
            There(_, _, _, _, _) => ?,
        },
        Cons(r, rs) => h1.match _ {
            Here(s, _) => h2.match _ {
                Here(t, _) => ?,
                There(_, _, _, _, _) absurd,
            },
            There(_, _, _, _, _) => ?,
        },
    }
}

data HasType(ctx: Ctx, e: Exp, t: Typ) {
    TVar(ctx: Ctx, x: Nat, t: Typ, elem: Elem(x, t, ctx)) : HasType(ctx, Var(x), t),
    TLam(ctx: Ctx, t1: Typ, t2: Typ, e: Exp, body: HasType(Cons(t1, ctx), e, t2)) : HasType(ctx, Lam(e), FunT(t1, t2)),
    TApp(ctx: Ctx, t1: Typ, t2: Typ, e1: Exp, e2: Exp,
         e1_t: HasType(ctx, e1, FunT(t1, t2)),
         e2_t: HasType(ctx, e2, t1)): HasType(ctx, App(e1, e2), t2),
}

def HasType(ctx, Var(x), s).lemma(ctx:Ctx, x: Nat, s t: Typ, h_elem: Elem(x, t, ctx)) : Eq(Typ, s, t) {
    TVar(_, _, _, h_elem2) => ?,
    TLam(_, _, _, _, _) absurd,
    TApp(_, _, _, _, _, _, _) absurd,
}

data Exp {
    Var(x: Nat),
    Lam(body: Exp),
    App(lhs: Exp, rhs: Exp)
}

data Eval(e1 e2: Exp) {
    EBeta(e1 e2: Exp): Eval(App(Lam(e1), e2), e1.subst(0, e2.shift_up(0)).shift_down(0)),
    ECongApp1(e1 e1': Exp, h: Eval(e1, e1'), e2: Exp): Eval(App(e1, e2), App(e1', e2)),
    ECongApp2(e1 e2 e2': Exp, h: Eval(e2, e2')): Eval(App(e1, e2), App(e1, e2')),
    ECongLam(e1 e2: Exp, h: Eval(e1, e2)): Eval(Lam(e1), Lam(e2)),
}

data IsValue(e: Exp) {
    VLam(e: Exp): IsValue(Lam(e)),
}

data Progress(e: Exp) {
    PVal(e: Exp, h: IsValue(e)): Progress(e),
    PStep(e1 e2: Exp, h: Eval(e1, e2)): Progress(e1),
}

def Exp.shift_up(c: Nat): Exp {
    Var(x) => Var(x.geq(c).then_else(Nat, S(x), x)),
    Lam(e) => Lam(e.shift_up(S(c))),
    App(e1, e2) => App(e1.shift_up(c), e2.shift_up(c)),
}

def Exp.shift_down(c: Nat): Exp {
    Var(x) => Var(x.geq(c).then_else(Nat, x.pred, x)),
    Lam(e) => Lam(e.shift_down(S(c))),
    App(e1, e2) => App(e1.shift_down(c), e2.shift_down(c)),
}

def Exp.subst(v: Nat, by: Exp): Exp {
    Var(x) => x.eq(v).then_else(Exp, by, Var(x)),
    Lam(e) => Lam(e.subst(S(v), by.shift_up(0))),
    App(e1, e2) => App(e1.subst(v, by), e2.subst(v, by)),
}

def (self: Exp).progress(t: Typ): Fun(HasType(Nil, self, t), Progress(self))
{
    Var(x) => comatch _ { apply(_, _, h) => h.match _ {
        TVar(_, _, _, elem) => elem.empty_absurd(x, t).elim_bot(Progress(Var(x))),
        TLam(_, _, _, _, _) absurd,
        TApp(_, _, _, _, _, _, _) absurd,
    }},
    Lam(e) => comatch _ { apply(_, _, h) => PVal(Lam(e), VLam(e)) },
    App(e1, e2) => comatch _ { apply(_, _, h) =>
        h.match _ {
            TVar(_, _, _, _) absurd,
            TLam(_, _, _, _, _) absurd,
            TApp(_, t1, t2, _, _, e1_t, e2_t) =>
            e1.progress(FunT(t1, t2)).apply(HasType(Nil, e1, FunT(t1, t2)), Progress(e1), e1_t).match _ {
                PStep(_, e1', e1_eval_e1') => PStep(App(e1, e2), App(e1', e2), ECongApp1(e1, e1', e1_eval_e1', e2)),
                PVal(_, is_val) => is_val.match _ {
                    VLam(e) => PStep(App(Lam(e), e2), e.subst(0, e2.shift_up(0)).shift_down(0), EBeta(e, e2))
                },
            },
        }
    },
}

def (self: Exp).subst_lemma(ctx: Ctx, s t: Typ, x: Nat, by: Exp, h_elem: Elem(x, s, ctx), h_by: HasType(ctx, by, s)): Fun(HasType(ctx, self, t), HasType(ctx, self.subst(x, by), t)) {
    Var(y) => comatch _ { apply(_, _, h_self) => y.eq(x).match _ as z => HasType(ctx, z.then_else(Exp, by, Var(y)), t) {
            False => h_self,
            True => (?).transport(Typ, s, t, comatch _ { apply(_, _, r) => HasType(ctx, by, r) }, h_by),
        }
    },
    App(e1, e2) => ?,
    Lam(e) => ?,
}

def (self: Exp).preservation(
    ctx: Ctx, e2: Exp, t: Typ,
): Fun(HasType(ctx, self, t), Fun(Eval(self, e2), HasType(ctx, e2, t)))
{
    Var(_) => ?,
    Lam(_) => ?,
    App(_, _) => ?,
}
