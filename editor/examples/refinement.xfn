codata Prop(a: Type, x: a) {
    Prop(a, x).apply'(a: Type, x: a) : Type
}

codata Fun(a: Type, b: Type) {
    Fun(a, b).apply(a: Type, b: Type, x: a) : b
}

data Eq (a: Type, x: a, y: a) {
    Refl(a: Type, x: a) : Eq(a, x, x)
}

impl Eq {
    def Eq(a, x, y).sym(a: Type, x: a, y: a) : Eq(a, y, x) {
        Refl(a, x) => Refl(a, x)
    }

    def Eq(a, x, y).subst(a: Type, x: a, y: a, p: Prop(a, x)) : Prop(a, y) {
        Refl(a, x) => p
    }

    def Eq(a, x, y).trans(a: Type, x: a, y: a, z: a, h: Eq(a, y, z)) : Eq(a, x, z) {
        Refl(a, x) => h
    }

    def Eq(a, x, y).cong(a: Type, b: Type, x: a, y: a, f: Fun(a, b)) : Eq(b, f.apply(a, b, x), f.apply(a, b, y)) {
        Refl(a, x) => Refl(b, f.apply(a, b, x))
    }
}

data Bool { True, False }

impl Bool {
    def Bool.not: Bool {
        True => False,
        False => True,
    }

    -- def Bool.not_inverse: Eq(Bool, self, self.not.not) {
    --     True => Refl(Bool, True),
    --     False => Refl(Bool, False),
    -- }
}

-- codata Bool {
--     (self: Bool).not_self_inverse: Eq(Bool, self, self.not.not)
-- }

-- codef True: Bool {
--     (self: Bool).not_self_inverse => Refl(Bool, True),
-- }

