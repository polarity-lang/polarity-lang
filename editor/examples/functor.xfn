codata Fun(a b: Type) {
    Fun(a, b).ap(a: Type, b: Type, x: a) : b
}

data Eq (a: Type, x: a, y: a) {
    Refl(a: Type, x: a) : Eq(a, x, x)
}

codef Id(a: Type) : Fun(a, a) {
    ap(_, _, x) => x,
}

codef Compose(a: Type, b: Type, c: Type, f: Fun(a, b), g: Fun(b, c)) : Fun(a, c) {
    ap(_, _, x) => g.ap(b, c, f.ap(a, b, x))
}

codata Functor(f: Fun(Type, Type)) {
    Functor(t).map(t: Fun(Type, Type), a b: Type, g: Fun(a, b), x: t.ap(Type, Type, a)): t.ap(Type, Type, b),
    (f: Functor(t)).law_id(t: Fun(Type, Type), a: Type, x: t.ap(Type, Type, a)): Eq(t.ap(Type, Type, a), f.map(t, a, a, Id(a), x), x),
    (f: Functor(t)).law_compose(t: Fun(Type, Type), a b c: Type, g: Fun(a, b), h: Fun(b, c), x: t.ap(Type, Type, a)): Eq(t.ap(Type, Type, c), f.map(t, a, c, Compose(a, b, c, g, h), x), f.map(t, b, c, h, f.map(t, a, b, g, x)))
}

data Box(a: Type) {
    MkBox(a: Type, x: a): Box(a),
}

codef BoxFun: Fun(Type, Type) {
    ap(_, _, a) => Box(a),
}

-- FIXME: This definition currently leads to a panic
-- codef BoxFunctor: Functor(BoxFun) {
--     map(_, _, _, _, _) => ?,
--     law_id(_, _, _) => ?,
--     law_compose(_, _, _, _, _, _, _) => ?,
-- }
